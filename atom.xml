<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>插秧哥&#39;s Blog</title>
  
  <subtitle>Never Stop Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chayangge.com/"/>
  <updated>2019-04-28T09:13:08.000Z</updated>
  <id>http://chayangge.com/</id>
  
  <author>
    <name>插秧哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>instanceof</title>
    <link href="http://chayangge.com/2019/04/28/instanceof/"/>
    <id>http://chayangge.com/2019/04/28/instanceof/</id>
    <published>2019-04-28T08:42:47.000Z</published>
    <updated>2019-04-28T09:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>instanceof用来判断对象是否属于某种类型，比如：判断一个示例是否是某个对象的实现，也就是改示例是否属于该对象类型。</p><p>其原理呢，用另一个定义即可说明：instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置。</p><p>由此可得：一个对象instanceof于各个层级的<strong>proto</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    this.method1 = function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.method2 = function()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">function Man()&#123;</span><br><span class="line">    this.name = &apos;tom&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Man.prototype = new Person();</span><br><span class="line"> </span><br><span class="line">Man.prototype.m1 = function()&#123;&#125;</span><br><span class="line">Man.prototype.m2 = function()&#123;&#125;</span><br><span class="line"> </span><br><span class="line">var m = new Man();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(&apos;instace&apos;,m instanceof Man); // true</span><br><span class="line">console.log(&apos;instace&apos;,m instanceof Person); // true</span><br><span class="line">console.log(&apos;instace&apos;,m instanceof Object); // true</span><br><span class="line"></span><br><span class="line">// 还有以下都为true</span><br><span class="line">console.log(&apos;Person instanceof Function:&apos;,Person instanceof Function);</span><br><span class="line">console.log(&apos;Person instanceof Object:&apos;,Person instanceof Object);</span><br><span class="line">console.log(&apos;Function instanceof Object:&apos;,Function instanceof Object);</span><br></pre></td></tr></table></figure><p>下面是递归实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function _instanceof(left,right)&#123;</span><br><span class="line">    if(left === null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    let leftProto = left.__proto__;</span><br><span class="line">    let rightProto = right.prototype;</span><br><span class="line"></span><br><span class="line">    if(leftProto === rightProto)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;222&apos;);</span><br><span class="line">    return _instanceof(leftProto,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(_instanceof(m,Man));</span><br><span class="line">console.log(_instanceof(m,Person));</span><br><span class="line">console.log(_instanceof(m,Object));</span><br><span class="line">console.log(_instanceof(Person,Function));</span><br><span class="line">console.log(_instanceof(Function,Object));</span><br></pre></td></tr></table></figure><p>实现2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function _instanceof(leftVaule, rightVaule) &#123; </span><br><span class="line">    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值</span><br><span class="line">    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值</span><br><span class="line">    while (true) &#123;</span><br><span class="line">    if (leftVaule === null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (leftVaule === rightProto) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; </span><br><span class="line">        leftVaule = leftVaule.__proto__ </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题外话：有些属性在对象上，有些属性在对象的原型链上，有些属性在原型链的原型链上，有且仅有hasOwnProperty能够判断是否直接在对象属性上，因此for in遍历对象时要按需选择是否要判断hasOwnProperty。</p><p>当对象的一个属性是在其原型链上时，hasOwnProperty肯定为false，但取其原型链再hasOwnProperty则为true，以此类推后续原型链。</p><p>此外：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.__proto__ === Man.prototype === Object.getPrototypeOf(m)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;instanceof用来判断对象是否属于某种类型，比如：判断一个示例是否是某个对象的实现，也就是改示例是否属于该对象类型。&lt;/p&gt;
&lt;p&gt;其原理呢，用另一个定义即可说明：instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置。&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>对称加密与非对称加密</title>
    <link href="http://chayangge.com/2019/04/25/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>http://chayangge.com/2019/04/25/对称加密与非对称加密/</id>
    <published>2019-04-25T09:28:09.000Z</published>
    <updated>2019-04-26T02:03:22.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>A和B通信，为了保密，两人商定好，用每个字符向前推一位的加密方式传输，那么消息hello则被加密为ifmmp，B知道这个加密规则，收到后字母退一位，则解析出hello，这就是对称加密。</p><p>缺点也很明显：</p><ul><li>事先需要约定加密规则（秘钥），一旦被盗取，密文相当于明文</li><li>但凡知道秘钥，给所有人的消息都统一破解了，影响整体</li></ul><h3 id="非对称加密算法RSA"><a href="#非对称加密算法RSA" class="headerlink" title="非对称加密算法RSA"></a>非对称加密算法RSA</h3><p>非对称加密解决了上述两个问题。</p><ul><li>传消息之前先告知各自的公钥，然后用各自的私钥解密消息，公钥被盗取了也不怕</li><li>哪怕破解了，也仅是一对一，不用影响别人</li></ul><p>所以用非对称加密的传出方式是：</p><ul><li>1.因为公钥是公开的，任何人都能获取，所以通信前，先互换公钥</li><li>2.信息用对方的公钥加密</li><li>3.对方收到后，用自己私藏的私钥解密，也仅有私钥能（迅速）解密出信息</li></ul><p>至于其中的算法，参考：<br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p><p>如果没有私钥，也是能暴力破解的，时间以目前的计算机能力，花个几百上千年，收益明显小于成本，时间没有打不开的锁，打开成本很大的锁，我们就可以认为是安全的锁。</p><p>现在只有一个问题：<br>如果有C在最开始伪装成B，把自己的公钥发给A了，这个最初环节的冒充该怎么办？</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>我们需要引入一个东西，来弥补目前的漏洞：证明你发出的公钥是你的。</p><p>怎么证明呢？引入一个第三方的信得过的机构来着认证。当然这个第三方公证处也有自己的公钥和私钥。首先，第三方公证处拿要认证的公钥和公钥归属人信息用自己的【私钥】加密，密文写在了证书上。注意：公证处的公钥也是公开的。</p><p>当通信时，对方不仅提供自己的公钥，还要提供公钥的证书，接收方收到后，用公证处的公钥解密证书上的密文，判断解密出公钥和一起收到的公钥是否一致，一致则说明可靠。（密文是公证处私钥加密的，所以之能用公证处的公钥解开）</p><p>公证处的公钥就是【根证书】，我们的电脑上已经预装了。</p><h3 id="如何使用证书"><a href="#如何使用证书" class="headerlink" title="如何使用证书"></a>如何使用证书</h3><p>先拿个人信息去公证处申请，把成功后得到的证书，放在自己的服务器上，公证处的公钥【根证书】已经预装在电脑本地了，所以服务器向浏览器通信时，向浏览器发出自己公钥和证书，浏览器拿根证书解密证书上的密文，发现与收到公钥一样，判断为信任，从而建立起https加密链接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h3&gt;&lt;p&gt;A和B通信，为了保密，两人商定好，用每个字符向前推一位的加密方式传输，那么消息hello则被加密为ifmmp，B知道这个加密
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于CAS的SSO基本实现流程</title>
    <link href="http://chayangge.com/2019/04/23/%E5%9F%BA%E4%BA%8ECAS%E7%9A%84SSO%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/"/>
    <id>http://chayangge.com/2019/04/23/基于CAS的SSO基本实现流程/</id>
    <published>2019-04-23T14:16:11.000Z</published>
    <updated>2019-04-23T15:57:29.683Z</updated>
    
    <content type="html"><![CDATA[<p>CAS:中央认证服务（Central Authentication Service）。<br>SSO：单点登录（Single Sign On）。</p><p>当一个账号能需要登录多个系统时，比如用新浪微博登录新浪官网、邮箱等，是不需要反复输入账号密码登录的，其背后的实现机制就是SSO。</p><p>中央认证服务是SSO常见的实现方式，抽一个服务专门负责登录，并向各个子系统提供登录认证。</p><h3 id="1-未登录用户首次访问目标系统"><a href="#1-未登录用户首次访问目标系统" class="headerlink" title="1.未登录用户首次访问目标系统"></a>1.未登录用户首次访问目标系统</h3><p>此时cookie非常干净，目标系统没检索到任何登录信息，视为未登录状态，重定向到中央登录系统，重定向URL参数带上目标系统的信息，如系统id（后续使用）、地链接址（用于登陆后回调）。</p><h3 id="2-用户登录"><a href="#2-用户登录" class="headerlink" title="2.用户登录"></a>2.用户登录</h3><p>用户通过输入账号密码，提交到中央系统，密码正确后，视为登录成功，此时中央系统检索出用户的身份信息，以此生成特定cookie种在中央系统的域名下（而非目标登录系统），除了种这个重要及其cookie，还会产生一个code凭据，这个code是根据目标系统生成的，仅针对当前要访问的目标系统有效，且只一次性，验证后立马无效。</p><p>此时中央系统返回一个重定向到目标系统的链接，把code凭据作为参数挂载后面，除了code还有登录标志参数，利于目标系统检索判断其目的是登录。</p><h3 id="二次访问目标系统"><a href="#二次访问目标系统" class="headerlink" title="二次访问目标系统"></a>二次访问目标系统</h3><p>根据中央系统的重定向链接和code等登录相关参数，浏览器二次访问目标系统，系统检索到到登录标识且有code，则取code向中央系统验证，换取accessToken，如上所述，换取后code凭据立马失效，这一步的安全保障在于：</p><ul><li>请求发生在服务器和服务器之间</li><li>https加密链接</li><li>有BA验证</li><li>code一次性</li></ul><h4 id="用accessToken换取用户信息"><a href="#用accessToken换取用户信息" class="headerlink" title="用accessToken换取用户信息"></a>用accessToken换取用户信息</h4><p>目标服务器拿刚换取到的accessToken再次发起请求换取用户信息，如：姓名、id、邮箱等。这一步的保障在于：</p><ul><li>服务器请求服务器</li><li>https</li><li>有BA</li></ul><p>目标服务器总算拿到了用户信息，到这里中央认证在登录这一块的基本任务就完整成了，因为如何保存和处理用户信息是目标服务器的事了，只要和前端浏览器约定好登录验证方案即可，这里多种实现，有常规方案session和目前常见的JWT。</p><p>这里说一下JWT。</p><h3 id="JWT-（JSON-Web-Token）"><a href="#JWT-（JSON-Web-Token）" class="headerlink" title="JWT （JSON Web Token）"></a>JWT （JSON Web Token）</h3><p>目标系统根据用户信息以及accessToken（为什么也要包含accessToken？后续退出会说到）进行签名加密成一个token（密钥只有服务器知道），返回给前端浏览器，浏览器后续的请求都带上这个token来作为登录标志，所以后续没放目标系统收到请求中的token都会先解密出用户信息后，才会进行后续逻辑中间件的处理。JWT还有很多细节，最大的特点就是和浏览器器传输一个token密码，免去服务端保存一份用户信息，从而实现无状态的目的，减轻服务端保存session的压力和响应速度。</p><p>把token交给前端和后续请求带上token有两种方案：</p><ul><li>作为重定向的参数</li><li>种cookie</li></ul><p>请求带上token也有相应的两种（其实参数也能带，但肯定没人这么做）：</p><ul><li>放在请求头中</li><li>作为cookie</li></ul><p>这里整个登录流程就已经实现，下面说一下退出流程。</p><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>退出请求依然会带上token，根据token解密出登录信息和上述accessToken，拿accessToken去请求中央服务器的退出接口声明废弃此accessToken，然后清除cookie，如果cookie内容是token的话也就是清除了token，并在响在重定向到最开始的登录页或其他你想要的页面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CAS:中央认证服务（Central Authentication Service）。&lt;br&gt;SSO：单点登录（Single Sign On）。&lt;/p&gt;
&lt;p&gt;当一个账号能需要登录多个系统时，比如用新浪微博登录新浪官网、邮箱等，是不需要反复输入账号密码登录的，其背后的实现机
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>《金字塔原理》</title>
    <link href="http://chayangge.com/2019/03/23/%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B/"/>
    <id>http://chayangge.com/2019/03/23/《金字塔原理》/</id>
    <published>2019-03-23T12:49:15.000Z</published>
    <updated>2019-03-23T15:43:45.786Z</updated>
    
    <content type="html"><![CDATA[<p>其实很多书翻来覆去就说了一句话，《金字塔原理》这本书也是。<br>这句话就是写在书皮扉页上：</p><blockquote><p>金字塔的基本机构是：中心思想明确，结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先全局后细节，先结论后原因，先结果后过程。</p></blockquote><p>没错，这是一本工具书，本书的所有内容无非是对这段话，在表达、沟通上的详细论证和举例绘图描述，书中法门对经常汇报工作的高层来说已经是基本常识，对新人来说也谈不上高深，毕竟有些细节旁敲侧击是听说过的，经过系统性的描述和举例后会更加深刻，会清晰认识到到这本书果然是意如其名，从而在日后的沟通、写作、汇报细节上加以联=练习使用，从而成为自己的“常识”。</p><h3 id="为什么要使用金字塔原理"><a href="#为什么要使用金字塔原理" class="headerlink" title="为什么要使用金字塔原理"></a>为什么要使用金字塔原理</h3><p>也就是为什么对外输出表达要有结构？<br>数字7，或者类似范围的数字，大概5-9之间是人脑所能hold住的并发数，管理1-3个项目还是挺轻松的，5-9个项目或信息点同时汇过来，人脑就不行了，需要排个层级顺序，利于消化，并且：</p><p>人脑天然喜欢归类、抽象和总结，比如：</p><ul><li>从繁星中看到图案</li><li>从杂乱的图中看到人脸</li></ul><p>所以保证结构输出的原因是：</p><ul><li>头脑经历有限</li><li>头脑偏好归类、抽象信息，而不是杂乱分散</li></ul><h3 id="金字塔顶尖：结论先行"><a href="#金字塔顶尖：结论先行" class="headerlink" title="金字塔顶尖：结论先行"></a>金字塔顶尖：结论先行</h3><p>一步到位告诉结果，是汇报的首要前提，不要拖泥带水讲原因细节，假设有人向你汇报，你当然最想知道的就是结果如何，其次才会想了解背后原因过程。</p><h3 id="金字塔基座：原因平级归属，有逻辑，有顺序"><a href="#金字塔基座：原因平级归属，有逻辑，有顺序" class="headerlink" title="金字塔基座：原因平级归属，有逻辑，有顺序"></a>金字塔基座：原因平级归属，有逻辑，有顺序</h3><p>给出支撑结论的依据：之所以【这个结果】，是因为：1，2，3这么几项。注意：这里的1，2，3是平级且有关联的，且都是核心重头原因，如果原因1的背后还有细节子原因，请不要不在追加在后面，而是把子原因铺在下一个层级里。</p><p>归纳论点需要注意：</p><ul><li>论点之前有关联，属于同一逻辑范畴</li><li>任意上层是对其下层的总结概括</li><li>排好顺序，排序规则：按时间、大小前提，重要顺序，步骤顺序</li></ul><p>总之：纵向总结，横向逻辑统一。</p><h3 id="思考的自下而上方法"><a href="#思考的自下而上方法" class="headerlink" title="思考的自下而上方法"></a>思考的自下而上方法</h3><p>当你暂时还锚定不了一个主题，无法确定读者疑问或读者想了解什么，也就是还没有稳住金字塔塔尖，只有一对无机构的散点描述信息时，可以按自下而上的方法，构建你的金字塔：</p><ul><li>列出所有散落的点信息</li><li>找出这些点之间的关联，肯定有平级的，有关关系的，承上启下的等等</li><li>铺平，累加，找到这些点汇聚的结论，那就是金字塔塔尖</li></ul><p>自下而上完全是这本书的意外收获。</p><h3 id="信息自我归纳"><a href="#信息自我归纳" class="headerlink" title="信息自我归纳"></a>信息自我归纳</h3><p>例子：</p><blockquote><p>日本商人加大对中国的投资<br>美国商人加大对中国的投资<br>德国商人加大对中国的投资<br>可归纳为：<br>投资商们加大对中国的投资</p></blockquote><p>例子：</p><blockquote><p>日本商人加大对中国的投资<br>日本商人加大对印尼的投资<br>日本商人加大对马来的投资<br>可归纳为：<br>日本商人加大对东南亚的投资</p></blockquote><p>归纳的前提是有共同性，如果是其他分散的无关联地区则无法归纳，要记：将一个思想与其他思想共同写进谋篇文章的唯一理由，就是这个思想有利于对一个更高层次上的思想提供解释或支持。</p><h3 id="分组原则"><a href="#分组原则" class="headerlink" title="分组原则"></a>分组原则</h3><h4 id="因果别混杂"><a href="#因果别混杂" class="headerlink" title="因果别混杂"></a>因果别混杂</h4><p>计划行动步骤中，不要把行动和结果平级列入，要把结果写成对结果的“行动”，而非在行动中插一条无行为动作的结果信息描述。</p><h4 id="MECE原则"><a href="#MECE原则" class="headerlink" title="MECE原则"></a>MECE原则</h4><ul><li>各模块相互独立（mutually exclusive），相互排斥，不重叠</li><li>穷尽所有模块（collectively exhaustive），不遗漏</li></ul><p>本书最后，引用赫伯特·西蒙：解决问题只不过是通过对问题的表述，使解决方案不言自明。</p><p>于此类似的有吉德林法则：把难题清清楚楚地写出来，便已经解决了一半。</p><p>还有：暴露问题是解决的第一步。</p><p>而金字塔原理就是帮我们更好的描述问题，输出信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实很多书翻来覆去就说了一句话，《金字塔原理》这本书也是。&lt;br&gt;这句话就是写在书皮扉页上：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;金字塔的基本机构是：中心思想明确，结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先全局后细节，先结论后原因，先结果后过程。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://chayangge.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>js:模拟new</title>
    <link href="http://chayangge.com/2019/02/28/js-%E6%A8%A1%E6%8B%9Fnew/"/>
    <id>http://chayangge.com/2019/02/28/js-模拟new/</id>
    <published>2019-02-28T05:17:11.000Z</published>
    <updated>2019-04-28T08:42:13.482Z</updated>
    
    <content type="html"><![CDATA[<p>作为关键字new，也是可以模拟的，模拟之前，先看new的基本用法和作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function bar(name,age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.habit = &apos;game&apos;;</span><br><span class="line">&#125;</span><br><span class="line">bar.prototype.strength = 60;</span><br><span class="line">bar.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">let a = new bar(&apos;tom&apos;,10);</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(a.name);</span><br><span class="line">console.log(a.age);</span><br><span class="line">console.log(a.strength);</span><br><span class="line">a.sayName();</span><br></pre></td></tr></table></figure><p>实例a可以访问构造函数中的变量，也可以访问其原型prototype上的变量和方法，下面是实现，命名为objectFactory：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objectFactory(fn,a)&#123;</span><br><span class="line">    var obj = new Object();</span><br><span class="line">    var Constructor = [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    Constructor.apply(obj, arguments);</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，信息密度大，及其精妙。</p><p>补充用构造函数new对象的特例：构造函数返回是一个对象时直接返回对象，则返回对象(如果返回常规类型，则忽略return)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function test(a)&#123;</span><br><span class="line">    this.name = &apos;111&apos;;</span><br><span class="line">    return &#123;</span><br><span class="line">        sayName:() =&gt;&#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new test();</span><br><span class="line">console.log(a);</span><br><span class="line">a.sayName() // 111</span><br></pre></td></tr></table></figure><p>所以最终实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function objectFactory()&#123;</span><br><span class="line">    var obj = new Object(),</span><br><span class="line">    // 截取fn</span><br><span class="line">    fn = [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ = fn.prototype;</span><br><span class="line">    // 截取后续参数</span><br><span class="line">    var ret = fn.apply(obj, arguments);</span><br><span class="line"></span><br><span class="line">    return typeof ret === &apos;object&apos; ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为关键字new，也是可以模拟的，模拟之前，先看new的基本用法和作用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:模拟call、apply</title>
    <link href="http://chayangge.com/2019/02/26/js-%E6%A8%A1%E6%8B%9Fcall%E3%80%81apply/"/>
    <id>http://chayangge.com/2019/02/26/js-模拟call、apply/</id>
    <published>2019-02-26T15:08:36.000Z</published>
    <updated>2019-02-26T18:25:51.232Z</updated>
    
    <content type="html"><![CDATA[<p>call的用法：借窝下蛋，使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p><p>看个应用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var value = 456;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    value: 11,</span><br><span class="line">    test: function()&#123;</span><br><span class="line">        console.log(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">test.call(obj);</span><br></pre></td></tr></table></figure><p>如果不用call，我们的代码不得不这样，把test放到obj里才行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    // 需要把函数放在obj里才行</span><br><span class="line">    bar: function() &#123;</span><br><span class="line">        console.log(this.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); // 1</span><br></pre></td></tr></table></figure><p>demo中通过调用call，让test中this的指向改为obj。</p><h3 id="模拟call"><a href="#模拟call" class="headerlink" title="模拟call"></a>模拟call</h3><p>原生的call方法是挂载在Function.prototype上的，下面就模拟实现一个call2：<br>模拟原理：</p><ul><li>先把函数放在obj里，获得了想要的this指向</li><li>执行obj.函数</li><li>删除obj.函数，保证obj原状不变</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(obj)&#123;</span><br><span class="line">    obj.fn = this; // 重点：this指向的实例，Function的实例就是函数bar</span><br><span class="line">    obj.fn();</span><br><span class="line">    delete fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.call2(foo); // 1</span><br></pre></td></tr></table></figure><p>到这原理就讲完了，但call是能带参数的，且还有类似固定参数的apply呢<br>实现带参call2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(obj,a,b)&#123;</span><br><span class="line">    obj.fn = this;</span><br><span class="line">    obj.fn(a,b);</span><br><span class="line">    delete fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(a,b) &#123;</span><br><span class="line">    console.log(this.value,a,b);</span><br><span class="line">&#125;</span><br><span class="line">bar.call2(foo,1,2); // 1,1,2</span><br></pre></td></tr></table></figure><p>但现实中call的参数是不固定的，第第一位始终是要嫁接的obj，所以参数只能从arguments数组的第1为开始取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(context) &#123;</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    eval(&apos;context.fn(&apos; + args +&apos;)&apos;); // 重点：用eval拼接出参数（a,b,c）的效果，args会自动调用toString方法</span><br><span class="line">    delete context.fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">    console.log(age)</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call2(foo, &apos;kevin&apos;, 18); </span><br><span class="line">// kevin</span><br><span class="line">// 18</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p>有些函数需要返回：比如函数结果是return一个什么东西，比如return 一个obj对象之类:<br>还有 call可以传null的，传null意味着在全局window上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function bar(name, age) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        value: this.value,</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bar() // return出一个对象</span><br></pre></td></tr></table></figure><p>这里也是可以轻松实现的，原理是把fn执行的结果收集起来，再用return扔出去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(context) &#123;</span><br><span class="line">    var context = context || window; // 为null时，context为window</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    let result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;); // 重点：用result手机函数运行结果，并return出去</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result; // return 出去</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">    console.log(age)</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call2(foo, &apos;kevin&apos;, 18); </span><br><span class="line">// kevin</span><br><span class="line">// 18</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><h3 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h3><p>apply的唯一区别就是参数固定，所以第二个参数直接一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.apply = function (context, arr) &#123;</span><br><span class="line">    var context = Object(context) || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        var args = [];</span><br><span class="line">        for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&apos;arr[&apos; + i + &apos;]&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟bind"><a href="#模拟bind" class="headerlink" title="模拟bind"></a>模拟bind</h3><p>先看看bind的特性：</p><ul><li>依然是借窝下蛋的功能</li><li>但返回一个新的函数</li><li>函数可传参，且参数可以再bind的时候产一部分，在执行的时候再传一部分</li></ul><p>最简单实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 = function(obj)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return self.apply(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">let a = bar.bind2(foo);</span><br><span class="line">console.log(&apos;a:&apos;,a);</span><br><span class="line">a() // 1</span><br></pre></td></tr></table></figure><p>实现和原理见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;call的用法：借窝下蛋，使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。&lt;/p&gt;
&lt;p&gt;看个应用场景：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:变量解析</title>
    <link href="http://chayangge.com/2019/02/19/js-%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90/"/>
    <id>http://chayangge.com/2019/02/19/js-变量解析/</id>
    <published>2019-02-18T16:17:58.000Z</published>
    <updated>2019-02-20T06:10:20.027Z</updated>
    
    <content type="html"><![CDATA[<p>js在执行前会创建可执行上下文，执行上下文中中包含：</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><p>执行上下文中的变量我们称为：活动对象(activation object, AO)。</p><p><strong>js对执行上下文中的代码有两部处理：1.进入执行上下文，进行各自的声明；2.执行，对声明赋值</strong><br>进入阶段，其中变量对象的状态为：</p><ul><li>arguments即形参，被赋值的形参为key:value，未赋值的为key:undefined</li><li>函数声明，注意：函数的声明一定提前于变量</li><li>变量声明，只有声明变量占位，并没有值</li></ul><p>demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test(item1,item2)&#123;</span><br><span class="line">    console.log(item1,item2);  // 1,undefined</span><br><span class="line">    console.log(a); // undefined</span><br><span class="line">    console.log(c); // c()&#123;&#125;</span><br><span class="line">    var a = 3;</span><br><span class="line">    function c()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(1);</span><br></pre></td></tr></table></figure><p>进入阶段的AO是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        1: undefined,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    a: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之所以能正常打印a，是因为执行打印时，函数已经提前【扫描】了内部变量，arguments作为实参，有实参则有值，无实参则undefined，函数提前，变量声明提前，只是没赋值，此时为undefined，执行到后续的的复制命令时a才会为3.</p><p>改一下，把内部的var a = 3;去除var，变为a = 3 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test(item1,item2)&#123;</span><br><span class="line">    console.log(item1,item2);  // 1,undefined</span><br><span class="line">    console.log(a); // 此处会报错：ReferenceError: a is not defined</span><br><span class="line">    console.log(c); </span><br><span class="line">    a = 3;</span><br><span class="line">    function c()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(1);</span><br></pre></td></tr></table></figure><p>因为去除var后，没有变量声明，在进入时，上下文中根本不会声明变量a，在执行阶段发现本作用域中没有a，则往上找，依然没有，则报错。<br>在进入阶段的AO为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        1: undefined,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    // 根本没有a，也不存在undefined,</span><br><span class="line"></span><br><span class="line">    c: reference to function c()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数优于变量提前声明</li><li>变量与形参重名时，变量声明不影响形参，如下demo：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function test(item1,item2)&#123;</span><br><span class="line">    console.log(item1,item2); // 1, undefined</span><br><span class="line">    console.log(c); // c()&#123;&#125;  而不是undefined，因为函数提前</span><br><span class="line">    var c = 3;</span><br><span class="line">    function c()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    var item1;</span><br><span class="line">    console.log(item1); // 依然是1，没赋值，不会影响形参item1</span><br><span class="line">&#125;</span><br><span class="line">test(1);</span><br></pre></td></tr></table></figure><h3 id="与静态作用域的关系"><a href="#与静态作用域的关系" class="headerlink" title="与静态作用域的关系"></a>与静态作用域的关系</h3><p>上文中说过js的作用域是静态的，函数无论在哪里执行，其内部变量的作用域始终为创建函数是固定的，通过观察AO发现果然如此，在函数执行前去，创建作用域栈，解析当前作用域下的变量，产生了固定的AO。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js在执行前会创建可执行上下文，执行上下文中中包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量对象&lt;/li&gt;
&lt;li&gt;作用域链&lt;/li&gt;
&lt;li&gt;this&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行上下文中的变量我们称为：活动对象(activation object, AO)。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:静态作用域</title>
    <link href="http://chayangge.com/2019/02/18/js-%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://chayangge.com/2019/02/18/js-静态作用域/</id>
    <published>2019-02-18T05:03:42.000Z</published>
    <updated>2019-02-18T06:24:06.246Z</updated>
    
    <content type="html"><![CDATA[<p>作用域指代码中定义变量的区域，js是静态作用于，核心点在于：无论function在哪里执行，function中使用的变量，始终为定义function时的变量。<br><a id="more"></a><br>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 1</span><br></pre></td></tr></table></figure></p><p>无论foo在哪里执行，其寻找变量的始终为创建时全局的value，而非bar中定义的value。如果js是动态作用域那打印的肯定是2了。</p><p>换个复杂点的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>以及：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>毫无疑问：都是local scope，无论f在哪执行，哪怕被return出去，其中变量作用域始终为创建时的“local scope”。</p><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>上述demo中两个checkscope的实现方式虽然结果相同，但执行上下文栈是不同的：<br>当js执行一个函数的时候，会创建一个执行上下文压栈，当有n个执行任务的时候，通过执行上下文栈来管理执行顺序，然后挨个执行出栈，最后的栈低永远是全局上下文globalContext。<br>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fun3() &#123;</span><br><span class="line">    console.log(&apos;fun3&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun2() &#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure></p><p>所以执行上下文栈为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//先执行fn1</span><br><span class="line">ECStack.push(fn1)</span><br><span class="line"></span><br><span class="line">// 发现fn1里调用了fn2，再次创建一个执行上下文入栈</span><br><span class="line">ECStack.push(fn2)</span><br><span class="line"></span><br><span class="line">// 发现fn2里调用了fn3，再次创建一个执行上下文入栈</span><br><span class="line">ECStack.push(fn3)</span><br><span class="line"></span><br><span class="line">// 终于fn3得到执行，pop出栈</span><br><span class="line">ECStack.pop();</span><br><span class="line">// fun2执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// fun1执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// 最后ECStack中剩下globalContext</span><br></pre></td></tr></table></figure></p><p>那上述checkscope的demo中两个虽结果一样，但执行上线文栈为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(checkscope)</span><br><span class="line"></span><br><span class="line">//发现里面调用了f()</span><br><span class="line">ECStack.push(f)</span><br><span class="line"></span><br><span class="line">// 终于f得到执行，pop出栈</span><br><span class="line">ECStack.pop();</span><br><span class="line">// checkscope执行完毕</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><p>第二个checkscope()();的例子为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(checkscope)</span><br><span class="line"></span><br><span class="line">//checkscope()运行结束了，pop</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// 发现checkscope()后面又有个()，也就是还有执行任务f，那再push</span><br><span class="line">ECStack.push(f)</span><br><span class="line">// f执行完毕</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><p>完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作用域指代码中定义变量的区域，js是静态作用于，核心点在于：无论function在哪里执行，function中使用的变量，始终为定义function时的变量。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:按值传递</title>
    <link href="http://chayangge.com/2019/02/16/js-%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://chayangge.com/2019/02/16/js-按值传递/</id>
    <published>2019-02-16T07:29:10.000Z</published>
    <updated>2019-02-16T08:03:25.614Z</updated>
    
    <content type="html"><![CDATA[<p>js是按值传递的，这个值对原始数据类型来说是value，对引用型数据来说是引用（即地址）；<br><a id="more"></a><br>demo1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f(a,b,c) &#123;</span><br><span class="line">   a = 3;</span><br><span class="line">   b.push(&quot;foo&quot;);</span><br><span class="line">   c.first = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = 4;</span><br><span class="line">var y = [&quot;eeny&quot;, &quot;miny&quot;, &quot;mo&quot;];</span><br><span class="line">var z = &#123;first: true&#125;;</span><br><span class="line">f(x,y,z); // x:3 y:[&quot;eeny&quot;, &quot;miny&quot;, &quot;mo&quot;, &apos;foo&apos;]  z: &#123;first: false&#125;</span><br></pre></td></tr></table></figure></p><p>x 是原始数据，y、z是引用数据，传入函数内的是x的值3，y、z的引用地址，所以内部通过地址引用操作内存【堆】中的引用型数据。</p><h3 id="共享传递-？"><a href="#共享传递-？" class="headerlink" title="共享传递 ？"></a>共享传递 ？</h3><p>demo2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line">function foo(o) &#123;</span><br><span class="line">    o = 2;</span><br><span class="line">    console.log(o); //2</span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line">console.log(obj.value) // 1</span><br></pre></td></tr></table></figure></p><p>上述例子中obj传入函数中的是引用地址的拷贝，被命令为o，当这个地址被重新复制后，切断了原有向堆中的指向，被新赋值为原始数据2，而堆中的数据不变，且依然被obj变量指向着。 </p><p>这也被称为共享传递，但因为共享传递中传递的是地址，地址被一个变量代表着，所以在《js高程》中称js为值传递。</p><p>demo2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;a:1&#125;;</span><br><span class="line">a.x = a = &#123;a:2&#125;;</span><br><span class="line">console.log(a); // &#123;a:2&#125;</span><br><span class="line">console.log(a.x); // undefined  ??</span><br></pre></td></tr></table></figure><p>首先复制运算从右向左，且.符号优先级最大，a为{a:1}的引用地址（是个变量值），真正的引用数据有两个分别是：{a:1}和{a:2}，那么赋值运算可拆解为：</p><p>a.x = a = {a:2}; （新内存：{a:2}）赋值给 ==&gt; (引用地址a) 赋值给==&gt; （原内存a：{a:1}）.x</p><p>所以原内位置的数据被修改为：{a:1,x:{a:2}}<br>变量a指向的是新创建的内存：{a:2}<br>所以：a是{a:2} a.x是undefined<br>而老内存{a:1,x:{a:2}} 因为已经没有被任何变量引用，而被销毁。</p><p>为了验证老内存，防止被销毁，新建一个变量b来指向它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;a:1&#125;;</span><br><span class="line">let b = a;</span><br><span class="line">a.x = a = &#123;a:2&#125;;</span><br><span class="line">console.log(a); // &#123;a:2&#125;</span><br><span class="line">console.log(a.x); // undefined </span><br><span class="line">console.log(b); // &#123;a:1,x:&#123;a:2&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>变量b始终指向老内存{a:1}，且老内存被追加属性x后，不会被销毁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js是按值传递的，这个值对原始数据类型来说是value，对引用型数据来说是引用（即地址）；&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>package.json散落知识点</title>
    <link href="http://chayangge.com/2019/01/02/package.json%E6%95%A3%E7%82%B9%E6%8B%BE%E9%81%97/"/>
    <id>http://chayangge.com/2019/01/02/package.json散点拾遗/</id>
    <published>2019-01-02T03:07:16.000Z</published>
    <updated>2019-01-02T06:10:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集散落的package.json相关知识，日后会不断丰富和补充：<br><a id="more"></a></p><h3 id="自定义命令和内置命令"><a href="#自定义命令和内置命令" class="headerlink" title="自定义命令和内置命令"></a>自定义命令和内置命令</h3><p>我们都知道可以再script中定义命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;gulp&quot;,</span><br><span class="line">    &quot;mock-start&quot;: &quot;XXX&quot;,</span><br><span class="line">    &quot;lc-mock-start&quot;: &quot;XXX&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;npm run lint&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>但这些命令一些可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></p><p>有些则需要加run才行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run mock-start</span><br></pre></td></tr></table></figure></p><p>不需要加run的就是npm内置命令，出start之外还有：</p><ul><li>test</li><li>stop</li><li>restart</li></ul><h3 id="语义化版本号"><a href="#语义化版本号" class="headerlink" title="语义化版本号"></a>语义化版本号</h3><p>约定一个包的版本号包含3个数字：主版本号.小版本号.修订版本号。</p><ul><li>MAJOR 对应大的版本号迭代，做了不兼容旧版的修改时要更新 MAJOR 版本号</li><li>MINOR 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新MINOR版本号</li><li>PATCH 对应修订版本号，一般针对修复 BUG 的版本号<br>具体见：<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">https://semver.org/lang/zh-CN/</a></li></ul><h3 id="版本匹配"><a href="#版本匹配" class="headerlink" title="版本匹配"></a>版本匹配</h3><p>经常看到入校版本信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">   &quot;copy-to-clipboard&quot;: &quot;^3.0.8&quot;,</span><br><span class="line">   &quot;immutable&quot;: &quot;^3.8.2&quot;,</span><br><span class="line">   &quot;react&quot;: &quot;~16.3.2&quot;,</span><br><span class="line">   &quot;react-dom&quot;: &quot;*16.3.2&quot;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>版本前有^和~两个符号，代表的意思分别为：</p><ul><li>^ 大版本匹配：如^3.0.8会匹配大版本3下的所有小版本（从3.0.0到3.9.9）</li><li>~ 小版本匹配：如~3.0.8会匹配小版本3.0.X下的所有小版本(从3.0.0到3.0.9)</li><li>*代表安装最新版本的包</li></ul><p>所以不推荐^和*</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文收集散落的package.json相关知识，日后会不断丰富和补充：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>笔尖下的深刻——村上春树</title>
    <link href="http://chayangge.com/2018/12/28/%E7%AC%94%E5%B0%96%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%88%BB%E2%80%94%E2%80%94%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/"/>
    <id>http://chayangge.com/2018/12/28/笔尖下的深刻——村上春树/</id>
    <published>2018-12-28T08:57:33.000Z</published>
    <updated>2018-12-28T11:40:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章太美，忍不住挂在博客上：<br><a id="more"></a></p></blockquote><hr><p>每一个人都有属于自己的一片森林，迷失的人迷失了，相逢的人会再相逢。</p><p>如果我爱你，而你也正巧的爱我。你头发乱了时候，我会笑笑的替你拨一波，然后，手还留恋的在你发上多待几秒。但是，如果我爱你，而你不巧的不爱我。你头发乱了，我只会轻轻的告诉你，你头发乱了喔。这大概是最纯粹的爱情观，如若相爱，便携手到老;如若错过，便护他安好。</p><p>尽管世界上有那般广阔的空间，而容纳你的空间——虽然只需一点点——却无处可寻。</p><p>于是我关闭我的语言，关闭我的心，深沉的悲哀是连眼泪这形式都无法采取的东西。</p><p>你要做一个不动声色的大人了。不准情绪化，不准偷偷想念，不准回头看。去过自己另外的生活。你要听话，不是所有的鱼都会生活在同一片海里。</p><p>我一直以为人是慢慢变老的，其实不是，人是一瞬间变老。</p><p>试着这样想：我们每一个人，都或多或少地，是一枚鸡蛋。我们每一个人都是一个独特的、不可替代的灵魂，而这灵魂覆盖着一个脆弱的外壳。这就是我自己的真相，而且这也是你们每一个人的真相。</p><p>不管全世界所有人怎么说，我都认为自己的感受才是正确的。无论别人怎么看，我绝不打乱自己的节奏。喜欢的事自然可以坚持，不喜欢的怎么也长久不了。</p><p>每一次，当他伤害我时，我会用过去那些美好的回忆来原谅他，然而，再美好的回忆也有用完的一天，到了最后只剩下回忆的残骸，一切都变成了折磨，也许我的确是从来不认识他。</p><p>这是个无情的世界，因为有希望的地方就必定有磨炼。</p><p>孤独一人也没关系，只要能发自内心地爱着一个人，人生就会有救。哪怕不能和他生活在一起。</p><p>人，人生，在本质上是孤独的，无奈的。所以需要与人交往，以求相互理解。然而相互理解果真可能吗?不，不可能，宿命式的不可能，寻求理解的努力是徒劳的。与其勉强通过交往来消灭孤独，化解无奈，莫如退回来把玩孤独，把玩无奈!</p><p>世界上有什么不会失去的东西吗？我相信有，你也最好相信。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章太美，忍不住挂在博客上：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack loader</title>
    <link href="http://chayangge.com/2018/12/24/webpack%20loader/"/>
    <id>http://chayangge.com/2018/12/24/webpack loader/</id>
    <published>2018-12-23T17:36:34.000Z</published>
    <updated>2018-12-23T17:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先熟悉loader"><a href="#先熟悉loader" class="headerlink" title="先熟悉loader"></a>先熟悉loader</h3><p>webpack只能处理js，对于非js的文件需要对应的loader转换成webpack能处理的模块，在进行打包，如JSX、TS、less等。</p><p>loader本质上是一个function，且按照node普通模块的方式编写，既可以是本地的一个文件，也可以打成一个npm包（项目中都是npm）。function用参数传入代码，然后按转换代码，最后输出代码。</p><h3 id="loader基本用法"><a href="#loader基本用法" class="headerlink" title="loader基本用法"></a>loader基本用法</h3><p>官方是使用方法这里过多介绍，只说明一下自己开发的本地loader使用方式，下面自己实现处理less的两个常用loader，分别为’style-loader’, ‘less-loader’，后者翻译less，前者把翻译后的css插入前端代码中。</p><p>在webpack.config.js中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;, // 入口文件</span><br><span class="line">    output: &#123; // webpack打包后出口文件</span><br><span class="line">        filename: &apos;build.js&apos;, // 打包后js文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;) // 打包后自动输出目录</span><br><span class="line">    &#125;,</span><br><span class="line">    resolveLoader: &#123;</span><br><span class="line">        // 定义自己的loader位置</span><br><span class="line">        modules: [path.resolve(__dirname, &apos;loaders&apos;)]</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &apos;source-map&apos;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        // loader 默认从右向左、从下往上执行，可用enforce：‘pre’ normal,inlineLoader,post设定最先执行</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                use: [&apos;style-loader&apos;, &apos;less-loader&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如上所示，用resolveLoader定义了loader的读取位置为本地的loaders文件夹，下面在该文件夹中定义这两个laoder的js文件，先以less-loader为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    // 这里处理source</span><br><span class="line">    console.log(&apos;我是自定义loader&apos;);</span><br><span class="line">    return source;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>此时运行webpack，会执行此loader并打印:’我是自定义loader。</p><p>loader作为一个流水线上的某个处理环节，传入了内容（String或Buffer），处理内容，最后输出内容，且输出作为下一个loader的输入，下面加入处理程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let less = require(&apos;less&apos;);</span><br><span class="line">function loader (source) &#123;</span><br><span class="line">    console.log(&apos;run loader...222&apos;, source);</span><br><span class="line">    console.log(&apos;this:&apos;, this);</span><br><span class="line">    let css;</span><br><span class="line">    less.render(source, function (error, output) &#123;</span><br><span class="line">        css = output.css;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&apos;我是翻译后的css:&apos;, css);</span><br><span class="line">    return css;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>至此，一个最基本的less文件loader就已经实现。</p><p>下面是style-loader，其作用是把css代码按最基础的方式插入页面中，所谓最基础的方式就是把css代码拼到style标签中，单后插入head标签里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    let str = `</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = $&#123;JSON.stringify(source)&#125;</span><br><span class="line">        document.head.appendChild(style)</span><br><span class="line">    `;</span><br><span class="line">    console.log(&apos;我是拼接好的插入代码：&apos;, str);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>运行webpack –mode development，会看到输出结果，并在dist目录中的未压缩build.js中看到具体的css代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/***/ &apos;./src/index.js&apos;:</span><br><span class="line">    /*! **********************!*\</span><br><span class="line">  !*** ./src/index.js ***!</span><br><span class="line">  \**********************/</span><br><span class="line">    /*! no static exports found */</span><br><span class="line">    /***/ function (module, exports, __webpack_require__) &#123;</span><br><span class="line">        __webpack_require__(/*! ./index.less */ &apos;./src/index.less&apos;);</span><br><span class="line">        document.querySelector(&apos;#root&apos;).innerHTML = &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos;;</span><br><span class="line">        /***/ &#125;,</span><br><span class="line"></span><br><span class="line">    /***/ &apos;./src/index.less&apos;:</span><br><span class="line">    /*! ************************!*\</span><br><span class="line">  !*** ./src/index.less ***!</span><br><span class="line">  \************************/</span><br><span class="line">    /*! no static exports found */</span><br><span class="line">    /***/ function (module, exports) &#123;</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = &apos;h1 &#123;\n  color: red;\n&#125;\n&apos;;</span><br><span class="line">        document.head.appendChild(style);</span><br><span class="line">        /***/ &#125;</span><br><span class="line"></span><br><span class="line">/******/ &#125;);</span><br></pre></td></tr></table></figure><p>在浏览器打开，将看到红色的hello word，说明两个loader已经正常运行。</p><h3 id="pitch"><a href="#pitch" class="headerlink" title="pitch"></a>pitch</h3><p>每个loader的function都有pitch属性方法，虽然loader的执行方式是从右向左，总下往上，但每个loader的pich是按常规顺序执行的，可以在某个laoder中打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    let str = `</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = $&#123;JSON.stringify(source)&#125;</span><br><span class="line">        document.head.appendChild(style)</span><br><span class="line">    `;</span><br><span class="line">    console.log(&apos;我是拼接好的插入代码：&apos;, str);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line">loader.pitch = function () &#123;</span><br><span class="line">    console.log(&apos;我是less-loader的pitch，我先执行&apos;);</span><br><span class="line">    //return &apos;source&apos; 一旦return，后续的loader将不执行</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure><p>当pitch中有return时，不在执行后面的loader，pitch在内部是以递归方式执行，当递归到底时，再执行loader，类似于koa中间件的洋葱模型，或理解为先入后出的栈模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|- style-loader `pitch`</span><br><span class="line">  |- less-loader `pitch`</span><br><span class="line">    // 递归到底</span><br><span class="line">  |- less-loader normal execution</span><br><span class="line">|- style-loader normal execution</span><br></pre></td></tr></table></figure></p><p>上面所写的两个loader过于简单，未涉及loader中的this，在每一个loader的上下文中都能通过this获取到loader的相关API，应对更多的功能场景，关于更多this上的API见<a href="https://webpack.js.org/api/loaders/" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先熟悉loader&quot;&gt;&lt;a href=&quot;#先熟悉loader&quot; class=&quot;headerlink&quot; title=&quot;先熟悉loader&quot;&gt;&lt;/a&gt;先熟悉loader&lt;/h3&gt;&lt;p&gt;webpack只能处理js，对于非js的文件需要对应的loader转换成webpac
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://chayangge.com/2018/11/26/Promise/"/>
    <id>http://chayangge.com/2018/11/26/Promise/</id>
    <published>2018-11-25T17:52:02.000Z</published>
    <updated>2018-11-26T02:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>越是高级语言，高封装度的框架，使用起来代码越倾向于配置，就像css，几乎就是一门纯配置语言。<br>Promise一直在用，基本都是在写Promise的配置，现在想想还是研究一下内部。<br><a id="more"></a><br>Promise主要解决嵌套异步回调问题，退一步想，只是代码形式上的“重组”，而promise就是重组嵌套代码的盒子，这个盒子规定：把触发逻辑写在resolve里，回调都写在then里，这样的代码形式则变得优雅很多。</p><p>回调地狱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./test.txt&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">    fs.readFile(data,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">        fs.readFile(data,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Promis后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function read(filePath,encoding)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">            if(err) &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(&apos;./test.txt&apos;,&apos;utf8&apos;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return read(data,&apos;utf8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return read(data,&apos;utf8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return data.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)...</span><br></pre></td></tr></table></figure></p><p>当然，应用广泛的Promise是有规范的，可以根据规范自己实现。规范也是人定的，甚至还可以抛弃规范去写自己心目中的代码。</p><p>如上面所说，Promise是代码形式上的“重组”工具，把触发代码和回调代码，以利于阅读和维护的方式重组，其中触发代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">    if(err) &#123;</span><br><span class="line">    reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>回调代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这样理解起来，对Promise整体就有了全局的认识，接下来要实现的就是这个工具，这个工具的核心是：</p><ul><li>1.触发函数在新建Promise时先执行，并根据结果设定好是走resolve还是reject</li><li>2.then里的回调函数在触发后执行，这就意味着要先注册这些回调（resolve回调和reject的回调）</li><li>3.Promise要能链式调用，且每个链式产生的是一个全新的Promise（非jQuery中直接return this，而是return new Promise）</li></ul><p>###最小Promise<br>先实现一个最小功能的Promise，仅实现上述1，2功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Promisee(fn)&#123;</span><br><span class="line">    this.state = &apos;PENDING&apos;;</span><br><span class="line">    this.value = null;</span><br><span class="line"></span><br><span class="line">    resolve = (value) =&gt; &#123;</span><br><span class="line">        this.state = &apos;RESOLVED&apos;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    reject = (error) =&gt; &#123;</span><br><span class="line">        this.state = &apos;REJECTED&apos;</span><br><span class="line">        this.value = error;</span><br><span class="line">    &#125;;</span><br><span class="line">    fn(resolve,reject)</span><br><span class="line">&#125;</span><br><span class="line">Promisee.prototype.then = function(onResole,onReject)&#123;</span><br><span class="line">        if(this.state === &apos;RESOLVED&apos;)&#123;</span><br><span class="line">            onResole(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;REJECTED&apos;)&#123;</span><br><span class="line">            onReject(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>触发逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let t = new Promisee((resolve,reject) =&gt; &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    resolve(a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t.then((value)=&gt;&#123;</span><br><span class="line">    console.log(&apos;执行成功：&apos;,value);</span><br><span class="line">&#125;,(value) =&gt; &#123;</span><br><span class="line">    console.log(&apos;执行失败：&apos;,value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上述就是最简易的Promise，上来就先执行了resolve，然后执行了then中onResole的回调。</p><p>但在实际中Promise的触发逻辑都是异步的，比如发起请求，这里用setTimeout模拟：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let t = new Promisee((resolve,reject) =&gt; &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(a);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里因为触发函数是异步的，所以then优先于resolve执行，而此时的状态还是最初的PEDDING，为此，Promise要继续丰富这种情况，保证then里的代码优先注册，必须当resolve执行后，才执行then中注册的回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Promisee(fn)&#123;</span><br><span class="line">    this.state = &apos;PENDING&apos;;</span><br><span class="line">    this.value = null;</span><br><span class="line">    this.onResolvedCallback = [];</span><br><span class="line">    this.onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">    resolve = (value) =&gt; &#123;</span><br><span class="line">        this.state = &apos;RESOLVED&apos;</span><br><span class="line">        this.value = value;</span><br><span class="line">        console.log(this.onResolvedCallback.length);</span><br><span class="line">        for(var i = 0; i &lt; this.onResolvedCallback.length; i++) &#123;</span><br><span class="line">            this.onResolvedCallback[i](value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    reject = (error) =&gt; &#123;</span><br><span class="line">        this.state = &apos;REJECTED&apos;</span><br><span class="line">        this.value = error;</span><br><span class="line">        for(var i = 0; i &lt; this.onRejectedCallback.length; i++) &#123;</span><br><span class="line">            this.onRejectedCallback[i](error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    fn(resolve,reject)</span><br><span class="line">&#125;</span><br><span class="line">Promisee.prototype.then = function(onResole,onReject)&#123;</span><br><span class="line">        if(this.state === &apos;RESOLVED&apos;)&#123;</span><br><span class="line">            onResole(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;REJECTED&apos;)&#123;</span><br><span class="line">            onReject(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;PENDING&apos;)&#123;</span><br><span class="line">            this.onResolvedCallback.push(onResole);</span><br><span class="line">            this.onRejectedCallback.push(onReject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>仔细对比改造前后的代码，会发现有以下核心改动点：</p><ul><li>then里当PENDING状态时分别存到onResolvedCallback和onRejectedCallback数组里，解决了上述中因异步触发函数导致缺失PENDING状态的问题</li><li>resolve或reject执行时，遍历各自的数组栈，把之前then中存进去的回调函数通通在此时执行</li></ul><p>这时候的触发函数终于可以写成常见的异步了。</p><p>下面只剩下一个问题3：then链式调用，then返回的是一个全新的Promise，需在then的三种情况下都返回一个new Promise，且新promise的输入是上一个promise的输出，也就是上一个promise中then里的回调函数执行结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越是高级语言，高封装度的框架，使用起来代码越倾向于配置，就像css，几乎就是一门纯配置语言。&lt;br&gt;Promise一直在用，基本都是在写Promise的配置，现在想想还是研究一下内部。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符、ASCII码、Unicode、UTF-8、emoji</title>
    <link href="http://chayangge.com/2018/10/30/UTF-8/"/>
    <id>http://chayangge.com/2018/10/30/UTF-8/</id>
    <published>2018-10-30T02:30:52.000Z</published>
    <updated>2018-12-30T13:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机供01高低电位表示信息，01也是最小逻辑单元。</p><p>一个字节由8个bit位表示，也就是一个字节最多能表示256个字符（256种组合）</p><p>ASCII码就是这种表示方法，但只用钱7位表达了128个字符，开头都是0，这128个字符包含常见的英文字母大小写，以及32个不能打印出来的控制符。</p><p>英文肯定是够用了，但有上万个字符的中文及其他语言就不行了。</p><p>所以GB2312编码来了，用两个字节表示一个汉字，也就是16个bit位，终于满足所有汉字了。</p><p>但每个语言都搞一套编码，不够国际化，别的编码方式的浏览器打开中文都是乱码。</p><p>所以Unicode出现了，uni + code （统一 + 编码）</p><p>终于能把全世界的语言字符表达完了。</p><p>但有个问题：浪费存储空间，很多排在后面的特殊字符要用4个甚至给更多字符表达，那就是32个bit位啊，如果只表达一个英文字母，8位就足够足够了，剩余的位置都要补0，空占位而已。</p><p>所以UTF-8 出现了。</p><p>UTF-8可以非常灵活根据不同字符，采用1-4个字符去表达，比如我们熟知的：英文1个字符，汉字两个字符，但要知道，有别的语言字符需要3-4个字符才能表达。</p><p>文字字符太单调了，不够生动形象，全球人类都能通过笑和哭的表情来表达信息，如果能有表情就好了，怎么办呢？</p><p>二次元的国都 —— 日本，率先发明了emoji，来解决这个问题，比如：😯😈😎😆☹️</p><p>e表示”絵”，moji表示”文字”。连在一起，就是”絵文字”，是不是很日文？</p><p>流行以后难免要统一起来，那就国际化吧：Unicode开始接纳emoji。所以，对计算机来说：</p><p>emoji就是字符，emoji就是字符，emoji就是字符。</p><p>现在emoji越来越多，都在<a href="http://www.unicode.org/emoji/charts/full-emoji-list.html" target="_blank" rel="noopener">这里</a>：<a href="http://www.unicode.org/emoji/charts/full-emoji-list.html" target="_blank" rel="noopener">http://www.unicode.org/emoji/charts/full-emoji-list.html</a></p><p>将来随着新名词的出现和老词汇的丰富，还会有更多emoji表情出现，所以我们正在经历电脑字符愈来愈多的年代。</p><p>为什么同样的笑脸emoji在不同的平台上长得稍微有些不一样呢？比如微信里的，和电脑里的，或其他语言平台安卓下的？</p><p>因为：Unicode只规定了Emoji在某个01组合位置的含义，并没有规定它的长相。所以假设1000101表示大笑，那不同的平台只要给出符合自己民情的笑脸样式即可。</p><p>话题跑远了，回到技术话题：当百度搜索你好时，看到的请求编码是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?wd=%E4%BD%A0%E5%A5%BD</span><br></pre></td></tr></table></figure></p><p>很明显汉字【你好】被编码成了【%E4%BD%A0%E5%A5%BD】，且还有这多%%%。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机供01高低电位表示信息，01也是最小逻辑单元。&lt;/p&gt;
&lt;p&gt;一个字节由8个bit位表示，也就是一个字节最多能表示256个字符（256种组合）&lt;/p&gt;
&lt;p&gt;ASCII码就是这种表示方法，但只用钱7位表达了128个字符，开头都是0，这128个字符包含常见的英文字母大小
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB备忘</title>
    <link href="http://chayangge.com/2018/09/17/MongoDB%E5%A4%87%E5%BF%98/"/>
    <id>http://chayangge.com/2018/09/17/MongoDB备忘/</id>
    <published>2018-09-17T06:39:30.000Z</published>
    <updated>2018-09-29T09:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近因业务原因，需登录机器手动操作MongoDB，每次操作每次查，现备份一次，方便日后：<br><a id="more"></a></p><ul><li>先登录机器</li><li>链接MongoDB：mongo 10.5.XX.XX:端口</li><li>show dbs</li><li>use 某db</li><li>show tables</li><li>db.sometable.find({‘_id’:’XX’});</li><li>db.sometable.update({条件},{$set:{key:value}},{multi:true}));</li></ul><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sometable.find(&#123;&apos;url&apos;:&#123;$regex:/key/i&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="新建表"><a href="#新建表" class="headerlink" title="新建表"></a>新建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&apos;表名&apos;)</span><br></pre></td></tr></table></figure><h3 id="关闭MongoDB"><a href="#关闭MongoDB" class="headerlink" title="关闭MongoDB"></a>关闭MongoDB</h3><ul><li>先退出：mongo –port 8415（只用端口号登录）</li><li>use admin</li><li>db.shutdownServer()</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>cd到MongoDB安装文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f mongod.conf</span><br></pre></td></tr></table></figure><h3 id="复制集"><a href="#复制集" class="headerlink" title="复制集"></a>复制集</h3><p>MongoDB数据库有多个节点时，会包含一个Primary节点和多个Secondary节点，数据先写入Primary节点，其他Secondary再从Primary中同步写入的数据，因此当连接数据库后，光标起始位置会显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某某db:PRIMARY&gt;</span><br></pre></td></tr></table></figure></p><p>或：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某某db:SECONDARY&gt;</span><br></pre></td></tr></table></figure></p><p>当要操作Secondary节点时，由于secondary节点默认不可读，会收到一下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,</span><br><span class="line">&quot;code&quot; : 13435,</span><br><span class="line">&quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;</span><br></pre></td></tr></table></figure></p><p>解决办法，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.slaveOk();</span><br></pre></td></tr></table></figure></p><p>但下次连接是依然报错，若想根治，则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.mongorc.js</span><br><span class="line"></span><br><span class="line">增加:rs.slaveOk();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因业务原因，需登录机器手动操作MongoDB，每次操作每次查，现备份一次，方便日后：&lt;br&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://chayangge.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手与SYN Flood攻击</title>
    <link href="http://chayangge.com/2018/09/08/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8ESYN-Flood%E6%94%BB%E5%87%BB/"/>
    <id>http://chayangge.com/2018/09/08/TCP三次握手与SYN-Flood攻击/</id>
    <published>2018-09-08T08:08:07.000Z</published>
    <updated>2018-10-30T02:19:35.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>三次握手大家都耳熟能详了：</p><ul><li>客户端发起握手信号SYN（Synchronize Sequence Numbers），然后进入 SYN_SEND 状态，等待服务端响应</li><li>服务端收到信号，返回SYN+ACK（Synchronization-Acknowledgement）信号，声明做好接收消息的准备，并要求客户端也要做好接收消息的准备，然后进入SYN_RCVD状态，也就是半开状态，服务端会持续等待客户端再次发起的确认信息，这个等待时间很长，能达到分钟级别。（注意：这里是攻击的核心点）</li><li>客户端收到消息后，再次发送ACK(Acknowledgement)消息给服务端，声明做好了接收数据的准备</li><li>连接成功</li></ul><h3 id="为什么三次？"><a href="#为什么三次？" class="headerlink" title="为什么三次？"></a>为什么三次？</h3><p>因为通信双方要互相告知自己的Sequence Numbers，这个序号将作为后续通讯的数字信号，TCP会议这个序号来拼接数据，以保证数据段的顺序。相当于两人如果发生转账，必须要先知到彼此的账号一样。</p><p>其次，三次是满足一个完整、妥善会话的最小逻辑单元，比如：</p><ul><li>A:我账号是001，求汇款500元？</li><li>B:可以，我的账号002，已向你转账500。</li><li>A:好的，收到！</li></ul><p>中间任何一步的失败都会造成会话的不完整，要么A不能确认B是否转账，要么B不能确认A是否收到汇款。</p><h3 id="SYN-Flood攻击"><a href="#SYN-Flood攻击" class="headerlink" title="SYN Flood攻击"></a>SYN Flood攻击</h3><p>如上所述，B转账后会处于半开放状态，要持续等待两分钟，直到收到A的确认收到汇款消息为止。等待是焦急的，劳神的，是耗费脑细胞的。当成千上万的虚假客户端只发送握手信号SYN，收到服务端信号后，并不再次发起确认信号时，服务端则会占用大量的系统内存来维持等待这些半开放的连接，耗尽系统资源，导致正常的握手请求得不到响应，这就是SYN Flood攻击的原理。</p><h3 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h3><ul><li>缩短SYN Timeout时间</li><li>提高半开状态数量</li><li>SYN cookie：<blockquote><p>服务端收到握手信号SYN，在返回SYN+ACK时对ACK进行加密，加密信息包含原地址、端口、目标地址，总之能标识是谁发来的信息，然后不进入半开放状态，直接释放所以状态，这样省去了维持等待所耗费的系统资源，当收到客户端字再次发起的ACK信号时，计算是否为上个SYN+ACK消息的返回，如果是则直接进入连接状态。</p></blockquote></li><li>Firewalls and Proxies：<blockquote><p>用防火墙作为客户端和服务端的中间代理，客户端先与防火墙建立三次握手，只有在握手成功后，防火墙再与服务端建立握手，然后防火墙在中间代理数据传输。此时服务端收到的都是正常握手请求。</p></blockquote></li></ul><p>参考：<a href="https://www.wikiwand.com/en/SYN_flood#" target="_blank" rel="noopener">https://www.wikiwand.com/en/SYN_flood#</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;三次握手大家都耳熟能详了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发起握手信号SYN（Synchronize Sequence Numbers），然后进入 SYN_SEND 状态，等待服务端响应&lt;/li&gt;
&lt;li&gt;服务端收到信号，返回SYN+A
      
    
    </summary>
    
    
      <category term="TCP" scheme="http://chayangge.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Base64</title>
    <link href="http://chayangge.com/2018/08/13/Base64/"/>
    <id>http://chayangge.com/2018/08/13/Base64/</id>
    <published>2018-08-12T16:03:30.000Z</published>
    <updated>2018-08-12T16:46:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，Base64不是加密方式，而是一种数据的编码方式，只是在视觉上起到了‘加密’的功能而已。</p><h3 id="为什么会有Base64？"><a href="#为什么会有Base64？" class="headerlink" title="为什么会有Base64？"></a>为什么会有Base64？</h3><p>Base64加密后的信息理论上会比原信息大三分之一左右，数据变大是不利于传输的，那什么优势让它依然被使用呢？</p><p>答案是因为早期的邮件传输协议SMTP只能传输可打印的ASCII码，那不支持传输的ASCII码只能换一种编码方式，用可传输的ASCII码部分来表示信息。</p><h3 id="用了哪些字符码"><a href="#用了哪些字符码" class="headerlink" title="用了哪些字符码"></a>用了哪些字符码</h3><p>虽然名叫base64，但实际用了65个字符，因为尾部用“=”表示结束，首先从0开始，到51位分别为大小写的字母a-z，52至61为数字0-9，另外加两个字符+/，正好64。<br>所以一个标准的base64编码数据就是大小写混合夹杂数字偶尔出现+/，结尾还会有“=”。</p><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>转换规则如下：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/base64.png" alt="转换规则"></p><p>直接看字母的二进制数据，base64把原本的8Bit一组的数据从新按6Bit一组，然后把这新的6位二进制转换成十进制，再从10进制中找到对应的字符，组成了base64的编码。这样，无论什么数据，都能用上述64个字符表达出来，而这64个字符在所有的协议中都能顺利传输。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>base64以增加传输数据变大为代价，换取了传输的兼容性，然后仅仅在肉眼上实现了‘加密’。</p><p>前端接触最多的应用场景是用于表达图片二进制信息，把不是很大的图片用base64标识，直接放在html或css中，省去浏览器再发一个资源请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，Base64不是加密方式，而是一种数据的编码方式，只是在视觉上起到了‘加密’的功能而已。&lt;/p&gt;
&lt;h3 id=&quot;为什么会有Base64？&quot;&gt;&lt;a href=&quot;#为什么会有Base64？&quot; class=&quot;headerlink&quot; title=&quot;为什么会有Base64？&quot;
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>天！居然断更了这么久</title>
    <link href="http://chayangge.com/2018/08/12/%E5%A4%A9%EF%BC%81%E5%B1%85%E7%84%B6%E6%96%AD%E6%9B%B4%E4%BA%86%E8%BF%99%E4%B9%88%E4%B9%85/"/>
    <id>http://chayangge.com/2018/08/12/天！居然断更了这么久/</id>
    <published>2018-08-12T06:31:05.000Z</published>
    <updated>2018-08-11T17:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>天！居然断更了这么久，</p><p>换了份工作，</p><p>把博客落下了，</p><p>适应工作节奏后，</p><p>总感觉时间不够用，</p><p>博客就：拖…</p><p>然后，服务器又到期了，</p><p>要不要买服务器呢？买哪家？</p><p>拖…</p><p>终于又买了服务器，</p><p>换了腾讯云，</p><p>可，备案居然要重新审核，</p><p>拖…</p><p>备案终于过了，</p><p>然而，本地博客跑不起来了，</p><p>还得修，</p><p>拖…</p><p>重装了博客、改了配置、再绑域名、装git、装nginx、nginx.config 等一系列操作，</p><p>终于完成了，</p><p>总耗时接近一年！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;天！居然断更了这么久，&lt;/p&gt;
&lt;p&gt;换了份工作，&lt;/p&gt;
&lt;p&gt;把博客落下了，&lt;/p&gt;
&lt;p&gt;适应工作节奏后，&lt;/p&gt;
&lt;p&gt;总感觉时间不够用，&lt;/p&gt;
&lt;p&gt;博客就：拖…&lt;/p&gt;
&lt;p&gt;然后，服务器又到期了，&lt;/p&gt;
&lt;p&gt;要不要买服务器呢？买哪家？&lt;/p&gt;
&lt;p&gt;拖…
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>0.1 + 0.2 !== 0.3</title>
    <link href="http://chayangge.com/2018/02/13/0-1-0-2-0-3/"/>
    <id>http://chayangge.com/2018/02/13/0-1-0-2-0-3/</id>
    <published>2018-02-13T08:23:48.000Z</published>
    <updated>2019-02-14T08:24:04.331Z</updated>
    
    <content type="html"><![CDATA[<p>老生常谈的问题了，之前查过一次，模糊记得js、java等语言都存在此问题，后来原因又忘了，最近碰到，再补充一下。</p><a id="more"></a><h3 id="计算机如何用二进制表达小数？"><a href="#计算机如何用二进制表达小数？" class="headerlink" title="计算机如何用二进制表达小数？"></a>计算机如何用二进制表达小数？</h3><blockquote><p>乘2取整，直至小数部分为0，然后把取的整数顺序排列</p></blockquote><p>比如：0.8125:</p><p>0.8125 <em> 2 = 1.625，取1，剩余0.625<br>0.625 </em>2 = 1.25，取1，剩余0.25<br>0.25 <em> 2 = 0.5，取0，剩余0.5<br>0.5 </em> 2 = 1.0，取1，终于剩余0.0<br>顺序排列取的整数得到二进制：1101，所以0.8125的二进制表达就是0.1101</p><p>那6.8125呢？</p><p>补充一下整数转换二进制规则：</p><blockquote><p>除2取余，直到商为0，然后倒着拼接余数</p></blockquote><p>如：6</p><p>6 / 2，得3余0<br>3 / 2，得1余1<br>1 / 2，得0余1<br>倒着拼接余数110即为6的二进制<br>所以综上所述6.8125的二进制位：110.1101</p><h3 id="出现误差的原因"><a href="#出现误差的原因" class="headerlink" title="出现误差的原因"></a>出现误差的原因</h3><p>例子是完美的，但很多数据的运算并不顺利，比如0.1</p><p>0.1 <em> 2 = 0.2 取0剩余0.2<br>0.2 </em> 2 = 0.4 取0剩余0.4<br>0.4 <em> 2 = 0.8 取0剩余0.8<br>0.8 </em> 2 = 1.6 取1剩余0.6<br>0.6 * 2 = 1.2 取1剩余0.2<br>….<br>永远不会剩余0，那就是一个无线循环的数0.0001100110011…（0011保持循环）。</p><p>这种情况：计算机会根据IEEE 754进行裁剪取整，这就是精度缺失的根本原因，至于截取规则，IEEE 754规定如果溢出的第一位是1，那就加1，导致某些数据截取后比真实大那么一点点，0.1恰巧因最后的溢出是1，被进位。</p><p>总之精度缺失的原因来自计算机对无线循环的无奈</p><h3 id="总结、解决方案"><a href="#总结、解决方案" class="headerlink" title="总结、解决方案"></a>总结、解决方案</h3><ul><li>认识到小数是不靠谱的，开发中避免直接此类判断0.1 + 0.2 === 0.3</li><li>toFixed也因此有坑：1.005.toFixed(2)，返回的是 <code>1.00</code> 而不是 <code>1.01</code></li><li>第三方工具：number-precision，bignumber.js，Math.js等，把数据转换成string进行处理，性能差点</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老生常谈的问题了，之前查过一次，模糊记得js、java等语言都存在此问题，后来原因又忘了，最近碰到，再补充一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>中间件</title>
    <link href="http://chayangge.com/2017/08/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://chayangge.com/2017/08/21/中间件/</id>
    <published>2017-08-21T03:56:16.000Z</published>
    <updated>2017-09-04T02:19:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>中间件，对新手来说又是个不明觉厉的词汇，简单地说，几乎所有的应用都是一个服务器收发的过程，客户端通过http发送请求，服务器收到请求后给出响应，这是整个互联网的运作方式，而中间件，顾名思义，就是在收发之间做逻辑处理。<br><a id="more"></a><br>业界有句名言：</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决<br>“Any problem  in computer science can be solved by anther layer of indirection.”</p></blockquote><p>仔细想一下很多问题都是通过添加独立的层的概念来解决的，包括一些已经作为常识的知识，比如：互联网层的划分，从底层的物理层，到上层的应用层，彼此层之间相互独立，各司其职，以后再有什么升级或改动，保证原有层不变的基础上，添加一个层承上启下，即可。比如HTTPS就是在HTTP的基础上多了一层加密层。</p><p>而中间件的概念貌似也是如此。一个中间件就是一个功能层，相互独立，各司其职。</p><p>以express中间件为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listen 3000...'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(middleware1);</span><br><span class="line">app.use(middleware2);</span><br><span class="line">app.use(middleware3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware1</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是1"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是1，out"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware2</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是2"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是2，out"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware3</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是3"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是3，out"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>app.use方法用来接收中间件1、2、3，其执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">listen 3000...</span><br><span class="line">我是1</span><br><span class="line">我是2</span><br><span class="line">我是3</span><br><span class="line">我是3，out</span><br><span class="line">我是2，out</span><br><span class="line">我是1，out</span><br></pre></td></tr></table></figure></p><p>为什么遇到next后就直接跳转，等所有next执行完毕才回溯执行各自next后面的代码呢？app.use内部又是怎么回事呢？</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从结果可以看出，多个中间件的执行顺序是按栈结构执行的，首先遇到next跳转到下一个中间件执行，直到最内部的中间值执行完毕后，才执行最内部中间件next后面的代码，执行完后才返回上一层执行上一层中间件next后面的代码，像极了洋葱图。</p><p>而在代码层面上，每当调用app.use添加中间件时，其实内部维护了一个数组，把这些追加的中间件push进去，然后反方向执行，先执行数组最末端的中间件，直到第一个push进去的中间件，这样就实现了上述中间件调用效果。demo：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中间件，对新手来说又是个不明觉厉的词汇，简单地说，几乎所有的应用都是一个服务器收发的过程，客户端通过http发送请求，服务器收到请求后给出响应，这是整个互联网的运作方式，而中间件，顾名思义，就是在收发之间做逻辑处理。&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://chayangge.com/tags/node/"/>
    
  </entry>
  
</feed>
