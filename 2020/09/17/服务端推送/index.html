<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 服务端推送 · 插秧哥's Blog</title><meta name="description" content="服务端推送 - 插秧哥"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://chayangge.com/atom.xml" title="插秧哥's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/chayangge" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">服务端推送</h1><div class="post-info">Sep 17, 2020</div><div class="post-content"><p>目前服务端推送的方式有：</p>
<ul>
<li>HTTP长连接模拟</li>
<li>websocket </li>
<li>Server-Sent Events（SSE基于HTML5）</li>
<li>HTTP2.0 服务端推送</li>
</ul>
<h2 id="HTTP长连接模拟"><a href="#HTTP长连接模拟" class="headerlink" title="HTTP长连接模拟"></a>HTTP长连接模拟</h2><p>通常有两种实现：</p>
<ul>
<li>服务端收到请求后，一直hold，直到有数据更新时才给出相应，并关闭连接，由客户端发起第二次长连接</li>
<li>服务端有更新后一直不关闭连接，用流的方式，不断发送后续更新的数据</li>
</ul>
<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>最为“正规的”全双工实时通信，这里不多介绍；</p>
<h2 id="Server-Sent-Events（SSE基于HTML5）"><a href="#Server-Sent-Events（SSE基于HTML5）" class="headerlink" title="Server-Sent Events（SSE基于HTML5）"></a>Server-Sent Events（SSE基于HTML5）</h2><p>本质上依然是单项通信，只能由服务端发起，服务端响应一个数据流，不断的发送数据，如视频播放，文件流下载；<br>基于客户端建立EventSource对象，服务端以text/event-stream 格式发送事件；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">if (window.EventSource) &#123;</span><br><span class="line">  // 建立 EventSource 对象链接服务器</span><br><span class="line">  const source = new EventSource(&apos;http://localhost:2000&apos;);</span><br><span class="line"></span><br><span class="line">  // 链接成功后会触发 open 事件</span><br><span class="line">  source.addEventListener(&apos;open&apos;, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;Connected&apos;);</span><br><span class="line">  &#125;, false);</span><br><span class="line"></span><br><span class="line">  // 服务器发送信息到客户端时，若是没有 event 字段，默认会触发 message 事件</span><br><span class="line">  source.addEventListener(&apos;message&apos;, e =&gt; &#123;</span><br><span class="line">    console.log(`data: $&#123;e.data&#125;`);</span><br><span class="line">  &#125;, false);</span><br><span class="line"></span><br><span class="line">  // 自定义 EventHandler，在收到 event 字段为 slide 的消息时触发</span><br><span class="line">  source.addEventListener(&apos;slide&apos;, e =&gt; &#123;</span><br><span class="line">    console.log(`data: $&#123;e.data&#125;`); // =&gt; data: 7</span><br><span class="line">  &#125;, false);</span><br><span class="line"></span><br><span class="line">  // 链接异常时会触发 error 事件并自动重连</span><br><span class="line">  source.addEventListener(&apos;error&apos;, e =&gt; &#123;</span><br><span class="line">    if (e.target.readyState === EventSource.CLOSED) &#123;</span><br><span class="line">      console.log(&apos;Disconnected&apos;);</span><br><span class="line">    &#125; else if (e.target.readyState === EventSource.CONNECTING) &#123;</span><br><span class="line">      console.log(&apos;Connecting...&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, false);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.error(&apos;Your browser doesn\&apos;t support SSE&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端text/event-stream：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">http.createServer((req, res) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  // 服务器声明接下来发送的是事件流</span><br><span class="line">  res.writeHead(200, &#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;text/event-stream&apos;,</span><br><span class="line">    &apos;Cache-Control&apos;: &apos;no-cache&apos;,</span><br><span class="line">    &apos;Connection&apos;: &apos;keep-alive&apos;,</span><br><span class="line">    &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 发送消息</span><br><span class="line">  setInterval(() =&gt; &#123;</span><br><span class="line">    res.write(&apos;event: slide\n&apos;); // 事件类型</span><br><span class="line">    res.write(`id: $&#123;+new Date()&#125;\n`); // 消息 ID</span><br><span class="line">    res.write(&apos;data: 7\n&apos;); // 消息数据</span><br><span class="line">    res.write(&apos;retry: 10000\n&apos;); // 重连时间</span><br><span class="line">    res.write(&apos;\n\n&apos;); // 消息结束</span><br><span class="line">  &#125;, 3000);</span><br><span class="line"></span><br><span class="line">  // 发送注释保持长链接</span><br><span class="line">  setInterval(() =&gt; &#123;</span><br><span class="line">    res.write(&apos;: \n\n&apos;);</span><br><span class="line">  &#125;, 12000);</span><br><span class="line">&#125;).listen(2000)</span><br></pre></td></tr></table></figure></p>
<p>为什么有了websocket还要有SSE？</p>
<ul>
<li>websocket全双工，SSE是以客户端发起的单向通信，如：股票、新闻推送全依赖服务端更新的场景；</li>
<li>SSE使用HTTP协议，无需而外的升级websocket复杂协议</li>
</ul>
<h2 id="HTTP2-0-服务端推送"><a href="#HTTP2-0-服务端推送" class="headerlink" title="HTTP2.0 服务端推送"></a>HTTP2.0 服务端推送</h2><p>这个属于HTTP2.0的细节，最容易被忽视，其能够检测html文档中的css、js等静态文件，而不需要等浏览器解析到，再而外发起请求，属于服务端推送在“性能优化”场景的应用。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2021/05/04/方法论：坚持和自律/" class="prev">上一篇</a><a href="/2019/05/09/http协议变迁/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2020/09/17/服务端推送/';
var disqus_title = '服务端推送';
var disqus_url = 'http://chayangge.com/2020/09/17/服务端推送/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2014 - 2021 <a href="http://chayangge.com">插秧哥</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>