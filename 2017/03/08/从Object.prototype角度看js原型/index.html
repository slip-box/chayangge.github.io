<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 从Object.prototype角度看js原型 · 插秧哥's Blog</title><meta name="description" content="javascript原型 原型链"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://chayangge.com/atom.xml" title="插秧哥's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/chayangge" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">从Object.prototype角度看js原型</h1><div class="post-info">Mar 8, 2017</div><div class="post-content"><p>js原型是该语言的核心本质，可以说，没理解js原型就没学会js，js中的各个对象通过原型链的层层引用实现了各种方法的继承。其中关系错综复杂，我们先从这些原型链的『根』开始：<br><a id="more"></a></p>
<h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><p>为什么说<code>Object.prototype</code>是原型链的根？我们先把它打印出来开始：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8B%E5%8D%887.41.38.png" alt="Object.prototype"><br>可见，其原型上有几个熟悉的方法：</p>
<ul>
<li>hasOwnProperty</li>
<li>isPrototypeOf</li>
<li>toLocaleString</li>
<li>toString</li>
<li>valueOf</li>
</ul>
<p>这里方法的功能不是本文重点，这里不做介绍。只要记着Object的原型上有这几个方法就好,且<strong>留意hasOwnProperty函数，具体原因后续说明</strong>此时我们回忆下js的引用类型有以下几种：</p>
<ul>
<li>Object</li>
<li>Function</li>
<li>Number</li>
<li>RegExp</li>
<li>Date</li>
<li>Boolean</li>
</ul>
<p>我们知道这些引用型的实例就是我们常用的对象，函数，数值，正则，日期和布尔型数据，也就是说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>首先，我们应该都知道new出的实例会继承父对象中prototype中的方法，比如我们打印Array.prototype：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/QQ20170308-194513.png" alt="Array.prototype"><br>我们看到，数组常用的方法都能在里面找到，所以new出来的数组实例arr自然拥有上述方法。但有个<strong>奇怪的函数hasOwnProperty</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(arr.hasOwnProperty)</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xprui.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8B%E5%8D%887.41.59.png" alt="arr.hasOwnProperty"><br>Array的原型中，也就是Array.prototype中并没有hasOwnProperty。</p>
<h2 id="arr-hasOwnProperty从哪里来？"><a href="#arr-hasOwnProperty从哪里来？" class="headerlink" title="arr.hasOwnProperty从哪里来？"></a>arr.hasOwnProperty从哪里来？</h2><p>答案就是从js的『根』中来，也就是来自Object.prototype。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.hasOwnProperty === <span class="built_in">Object</span>.prototype.hasOwnProperty) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>下面这句特别重要：<br>实例arr的属性方法来自实例化它的Array的原型（Array.prototype）,那Array.prototype中的方法又来自哪里？答案是：一部分是js根据Array类型特意内置的，比如说sort方法，其余类型就没有，还有一部分就是来自根：<code>Object.prototype</code>,通过神秘的<code>__proto__</code>来实现引用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.hasOwnProperty === <span class="built_in">Object</span>.prototype.hasOwnProperty) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.hasOwnProperty === <span class="built_in">Object</span>.prototype.hasOwnProperty) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>而<code>__proto__</code>指向实例化它的对象的原型，也就是：实例化它的对象的prototype：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.__proto__ === <span class="built_in">Array</span>.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>那Array.prototype对象（原型也是对象）是谁实例化的呢？上面已经揭晓，既然Array.prototype中引用了Object.prototype中的方法，自然：<br>console.log(Array.prototype.<strong>proto</strong> === Object.prototype) //true<br>到这里我们几乎可以这么理解：arr的根是Array.prototype，而Array.prototype的根，也就是js的根：<code>Object.prototype</code>,<code>Object.prototype</code>上的方法自然能被层层下属使用，hasOwnProperty就是最好的说明。<br>除Array外，其余也是如此：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="comment">// .......</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>为什么Object.prototype中有这么多方法，本文只拿hasOwnProperty来做说明，答案是因为：其余方法如toString，valueOf会根据数据类型情况而被重写，比如Date型和Boolean型的toString和valueOf就是被重写改造后的，并没用使用根中自带的，这里就不举例了。</p>
</blockquote>
<h2 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h2><p>既然Object.prototype是根，且里面的方法可以层层被继承使用，那么这里就验证一下：<br>我们在Object.prototype上新增一个方法test：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"这是来自js根中的方法！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建不同数据类型的实例:</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">arr.test(); <span class="comment">//这是来自js根的测试方法！</span></span><br><span class="line">b.test(); <span class="comment">//这是来自js根的测试方法！</span></span><br><span class="line">d.test(); <span class="comment">//这是来自js根的测试方法！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...毫无疑问所有的实例都拥有了test方法</span></span><br></pre></td></tr></table></figure></p>
<p>上述大范围从根上扩充只是测试，一般情况下我们针对某一类型进行扩充足矣，比如js的trim方法只去两头空格，不包括中间空格，那么我们只需针对String类型在其原型上创建去全部空格方法allTrim即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.allTrim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/\s+/g</span>,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"   aa  bb  cc   "</span>.allTrim(); <span class="comment">//aabbcc</span></span><br></pre></td></tr></table></figure></p>
<p>这样所有的字符串实例都有了allTrim方法，理解了js的原型，则理解了js的继承机制。</p>
<h2 id="一切皆空"><a href="#一切皆空" class="headerlink" title="一切皆空"></a>一切皆空</h2><p>既然Array、Function、Number的原型对象都通过<code>__proto__</code>引用自根<code>Object.prototype</code>，那么<code>Object.prototype</code>也是一个原型对象，它的根又来自哪里呢？答案是<code>null</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
<p>null 才是js原型链的终结。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/03/16/node连上数据库/" class="prev">上一篇</a><a href="/2017/03/05/2017-03-05 收割与被收割/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2017/03/08/从Object.prototype角度看js原型/';
var disqus_title = '从Object.prototype角度看js原型';
var disqus_url = 'http://chayangge.com/2017/03/08/从Object.prototype角度看js原型/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2014 - 2021 <a href="http://chayangge.com">插秧哥</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>