<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 《高性能网站建设指南》读书笔记 · 插秧哥's Blog</title><meta name="description" content="《高性能网站建设指南》读书笔记 - 插秧哥"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://chayangge.com/atom.xml" title="插秧哥's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/chayangge" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">《高性能网站建设指南》读书笔记</h1><div class="post-info">Mar 15, 2016</div><div class="post-content"><p>没错就是这本书：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/blogQQ20160315-0.png" alt="封面"><br><a id="more"></a></p>
<h2 id="1-性能黄金法则："><a href="#1-性能黄金法则：" class="headerlink" title="1.性能黄金法则："></a>1.性能黄金法则：</h2><p>只有10% ~ 20%的最终用户响应时间花在了下载HTML文档上。其余的80% ~ 90%时间花在了下载页面中的所有组件上。</p>
<h2 id="2-HTTP是C-S协议-除了常见的GET、POST请求还有HEAD、PUT、DELETE、OPTIONS和TRACE请求。"><a href="#2-HTTP是C-S协议-除了常见的GET、POST请求还有HEAD、PUT、DELETE、OPTIONS和TRACE请求。" class="headerlink" title="2.HTTP是C/S协议 除了常见的GET、POST请求还有HEAD、PUT、DELETE、OPTIONS和TRACE请求。"></a>2.HTTP是C/S协议 除了常见的GET、POST请求还有HEAD、PUT、DELETE、OPTIONS和TRACE请求。</h2><h2 id="3-304-Not-Modified"><a href="#3-304-Not-Modified" class="headerlink" title="3.304 Not Modified"></a>3.304 Not Modified</h2><p>304加快了页面加载速度，服务器在返回的响应中包含Last-Modified，该时间带遍组件的“新鲜”日期，下次请求浏览器通过If-Modified-Since把时间修改日期发给给服务器对比。相同说明没有变动，浏览器中缓存的文件是最新的，可用，服务器返回304，Not Modified，不再发送响应体，也就不用再对请求发送该文件，使页面整个响应更快。<br>详情：<a href="">详解304</a></p>
<h2 id="4-减少http请求"><a href="#4-减少http请求" class="headerlink" title="4.减少http请求"></a>4.减少http请求</h2><ul>
<li>1.图片地图（已经很少见）</li>
<li>2.css sprites</li>
<li>3.内联图片，并把data写在css里的background属性，而不写在<code>&lt;img&gt;</code>标签中减少请求数</li>
<li>4.合并js、css文件<h3 id="5-长期缓存-添加Expires头信息-配置Cache-Control"><a href="#5-长期缓存-添加Expires头信息-配置Cache-Control" class="headerlink" title="5.长期缓存 添加Expires头信息 配置Cache-Control"></a>5.长期缓存 <del>添加Expires头信息</del> 配置Cache-Control</h3></li>
</ul>
<p>HTTP 1.1协议中：<code>Cache-Control:public,max-age=31536000</code> max-age设定缓存有效时间为31536000秒（一年）！最大可设置为10年！<br>public表示可缓存，哪怕响应状态码无法缓存，响应也可缓存。但通常不必须，因为max-age已经表示可缓存。<br>private表示为单个用户的数据缓存，浏览器可缓存，但中继缓存不能缓存</p>
<h2 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h2><p>每个HTTP请求都会先建立打开一个socket连接，没建立新的socket连接都耗费时间，所以设置<code>Connection:keep-alive</code>可使浏览器在一个单独的连接上尽享多个请求。可通过<code>Connection:close</code>关闭。</p>
<h2 id="5-CDN-内容发布网络-Content-Delivery-Network"><a href="#5-CDN-内容发布网络-Content-Delivery-Network" class="headerlink" title="5.CDN(内容发布网络)Content Delivery Network"></a>5.CDN(内容发布网络)Content Delivery Network</h2><p>一组分布在不同地理位置的web服务器，像用户更加有效的发布内容，最近距离，解决网络拥挤，提高总体访问速度。各大公司几乎都有。我的博客用的七牛。</p>
<h2 id="配置ETag"><a href="#配置ETag" class="headerlink" title="配置ETag"></a>配置ETag</h2><p>ETag（Entity Tag）<strong>实体标签</strong>它决定了浏览器缓存文件和服务器文件是否有效。<br>ETag是一个文件的版本标志字符串，浏览器缓存后通过If-None-Match发送给服务器，匹配一致说明缓存文件是“新鲜”可用的，则返回304，而不在发送文件体。</p>
<h2 id="ETag的问题"><a href="#ETag的问题" class="headerlink" title="ETag的问题"></a>ETag的问题</h2><p>一个浏览器请求对应一个服务器，ETag是没问题的，但若有多个服务器（服务器集群）时，浏览器请求中的ETag依然唯一匹配众多服务器中的一个，10台服务器匹配成功的概率为十分之一。十次有九次依然重新下载返回200。</p>
<p>且If-None-Match比If-Modified-Since有更高的优先级。想只匹配时间，忽略ETage？这是http1.1规禁止的。必须要两个都一致才会返回304.</p>
<h2 id="Google-Developers上有关ETag的说明："><a href="#Google-Developers上有关ETag的说明：" class="headerlink" title="Google Developers上有关ETag的说明："></a><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" target="_blank" rel="noopener">Google Developers</a>上有关ETag的说明：</h2><p>ETag解决了max-age超时问题，当超出缓存时间后避免浏览器和服务器之间重新加载文件，使用了ETag，ETag通常是文件内容的哈希值或某个其他指纹码。客户端不用考虑如何生成，只需把ETag发送给服务器，如果相同则不用重新下载，哪怕max-age超出。</p>
<h2 id="no-cache"><a href="#no-cache" class="headerlink" title="no-cache"></a>no-cache</h2><p>no-cache表示必须先和服务器验证文件的有效性。先验证再进行后续操作，是否重发。</p>
<h2 id="no-store"><a href="#no-store" class="headerlink" title="no-store"></a>no-store</h2><p>直接禁止浏览器和所有中继缓存。使请求每次都是新的，比如客户隐私数据（Ajax）</p>
<h2 id="总之尽可能多的缓存50-以上，甚至90-，尽可能长的缓存时间，且为响应的文件提供效验令牌ETag，这样哪怕超时，令牌一样依然可以304。"><a href="#总之尽可能多的缓存50-以上，甚至90-，尽可能长的缓存时间，且为响应的文件提供效验令牌ETag，这样哪怕超时，令牌一样依然可以304。" class="headerlink" title="总之尽可能多的缓存50%以上，甚至90%，尽可能长的缓存时间，且为响应的文件提供效验令牌ETag，这样哪怕超时，令牌一样依然可以304。"></a>总之尽可能多的缓存50%以上，甚至90%，尽可能长的缓存时间，且为响应的文件提供效验令牌ETag，这样哪怕超时，令牌一样依然可以304。</h2><p>借用Google Developers一张图：缓存策略决策树<br><img src="http://7xprui.com1.z0.glb.clouddn.com/bloghttp-cache-decision-tree.png" alt="缓存策略决策树"></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>ETag包含一串标志码和ChangeNumber 如： <code>ETag:&quot;fabe08e29bce1:0&quot;</code><br>配置ETag或干脆移除ETag，只用时间做比较<br>配置ETag：设置服务器（Apache）通过FileETag指令从ETag中移除inode，使ETag只包含文件大小和时间戳。<br>IIS为所有服务器设置相同的ChangeNumber，保留时间戳作为ETag的另一部分信息。<br>这将导致：<br>Apache服务器下所有ETag只包含文件大小和时间戳。大量重复信息<br>IIS服务器下只有时间戳（因为ChangeNumber都一样，无可比性），大量重复信息<br>且这些无实际意义的重复信息又增加了响应、请求http头文件的大小。 所以干脆移除ETag：FileETag none</p>
<h2 id="优化ajax请求"><a href="#优化ajax请求" class="headerlink" title="优化ajax请求"></a>优化ajax请求</h2><p>Cache-Control不为no-store</p>
<h2 id="减少DNS查询"><a href="#减少DNS查询" class="headerlink" title="减少DNS查询"></a>减少DNS查询</h2><p>域名要转为IP地址，DNS提供转换，但转换耗费时间，浏览器自身缓存DNS，操作系统也保留DNS记录。如果浏览器没有该DNS记录，先向操作系统询问，如果操作系统也没有则向远程服务器查询对应的IP地址。</p>
<h2 id="压缩组件gzip"><a href="#压缩组件gzip" class="headerlink" title="压缩组件gzip"></a>压缩组件gzip</h2><h2 id="服务器返回响应"><a href="#服务器返回响应" class="headerlink" title="服务器返回响应"></a>服务器返回响应</h2><p>服务器返回响应时，会发出一组HTTP头信息，用来描述响应内容的：类型、长度、缓存指令、验证令牌等信息</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/04/06/去除图片底部空隙/" class="prev">上一篇</a><a href="/2016/03/09/如果你的网页在手机上无法缩放/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2016/03/15/《高性能网站建设指南》读书笔记/';
var disqus_title = '《高性能网站建设指南》读书笔记';
var disqus_url = 'http://chayangge.com/2016/03/15/《高性能网站建设指南》读书笔记/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2014 - 2021 <a href="http://chayangge.com">插秧哥</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>