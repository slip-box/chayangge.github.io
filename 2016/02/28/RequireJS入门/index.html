<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> RequireJS入门 · 插秧哥's Blog</title><meta name="description" content="RequireJS入门 - 插秧哥"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://chayangge.com/atom.xml" title="插秧哥's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/chayangge" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">RequireJS入门</h1><div class="post-info">Feb 28, 2016</div><div class="post-content"><p>javascript语言本身没有“文件包”的概念，不像其他“高大上”的语言那样需要哪个模块就导入相关“包”。最开始js只是写一个个简单的function，后来function多的时候，开始用µ一个大的自执行函数对这些function进行简易封装，比如jQuery就是一个大的function库，最常见的封装模式就是return出一个对象，对象中包含一个个function，并把这些功能模块相关代码单独抽出来成为一个个js文件，通过<code>&lt;script&gt;</code>标签摆放好引入到网页中，但js文件又逐渐多了起来，怎么破？那就开始用js“加载器”来管理这里js模块文件了，这里简单介绍一下require.js。<br><a id="more"></a><br>先看一张常见的图，就知道js模块化的必要了：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/blogQQ20160301-10.png" alt="没有使用RequireJS"></p>
<h2 id="引用require-js"><a href="#引用require-js" class="headerlink" title="引用require.js"></a>引用require.js</h2><p>首先，在页面head中引入require.js:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>RequireJS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/lib/require.js"</span> <span class="attr">data-main</span>=<span class="string">"js/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>data-main=&quot;js/main.js&quot;</code>定义了该页面js的入口为js文件夹下的main.js,可简写为<code>data-main=&quot;js/main&quot;</code>。</p>
<h2 id="入口main-js"><a href="#入口main-js" class="headerlink" title="入口main.js"></a>入口main.js</h2><p>下面是入口main.js:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'main.js执行'</span>);</span><br><span class="line">     a.sayA();</span><br><span class="line">     b.sayB();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>假设该页面需要a,b两个模块，那么就如上所示使用require()函数来实现加载执行，require有两个参数，第一个参数为数组，数组内包含了需索模块的集合，第二个参数是回调函数，该回调函数的参数就是前面需要加载的依赖模块，通过参数传入后在回电函数内使用，这里需要注意：</p>
<ul>
<li>数组中的各个模块根据AMD规范是异步加载的</li>
<li>依赖模块全部加载后，回调函数才会执行，不会产生第一张图中js文件上下顺序放置错误的问题<br>上述代码是在“理想”条件下，这里理想的假设：a.js和b.js和main.js都在同一目录下。<br>如果不在同意目录下呢？使用require.config()方法：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">　　　　baseUrl: <span class="string">"js/lib"</span>,   <span class="comment">//定义根部路</span></span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　<span class="string">"a"</span>: <span class="string">"a.js"</span>,</span><br><span class="line">　　　　　　<span class="string">"b"</span>: <span class="string">"b.js"</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果有外部资源CDN文件，或分散在各处的js文件，那就只能逐个定义路径：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">　　　　paths: &#123;</span><br><span class="line">　　　　　　<span class="string">"a"</span>: <span class="string">"./js/lib/a.js"</span>,</span><br><span class="line">　　　　　　<span class="string">"b"</span>: <span class="string">"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="define各个模块"><a href="#define各个模块" class="headerlink" title="define各个模块"></a>define各个模块</h2><p>这里该介绍每个模块的书写方式了，AMD规范要求每个模块都要单独抽成一个独立的js文件，且AMD规范要求每个模块包含在define()当中，所以单独的模块a应该这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"hello a!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		sayA:a</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>因此，现在很多插件的开头都做了AMD写法，经常看到如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"> root, factory </span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ) &#123;</span><br><span class="line">		<span class="comment">// AMD. Register as an anonymous module.</span></span><br><span class="line">		define( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			root.Reveal = factory();</span><br><span class="line">			<span class="keyword">return</span> root.Reveal;</span><br><span class="line">		&#125; );</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>( <span class="keyword">typeof</span> exports === <span class="string">'object'</span> ) &#123;</span><br><span class="line">		<span class="comment">// Node. Does not work with strict CommonJS.</span></span><br><span class="line">		<span class="built_in">module</span>.exports = factory();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Browser globals.</span></span><br><span class="line">		root.Reveal = factory();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那对于没有按照AMD规范书写的插件呢？当然可以加载，单用要shim配置一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">　　　　shim: &#123;</span><br><span class="line">　　　　　　<span class="string">'a'</span>:&#123;</span><br><span class="line">　　　　　　　　exports: <span class="string">'a'</span></span><br><span class="line">　　　　　　&#125;,</span><br><span class="line">　　　　　　<span class="string">'b'</span>: &#123;</span><br><span class="line">　　　　　　　　deps: [<span class="string">'c'</span>],</span><br><span class="line">　　　　　　　　exports: <span class="string">'b'</span></span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可看到shim对象里有两个属性，exports和deps：</p>
<ul>
<li>exports暴漏模块接口，相当于定义了该模块的名字，外部环境要使用该模块就调用exports导出的模块名,比如<code>jQuery</code>导出为<code>$</code></li>
<li>deps也是个数组，定义了改模块的依赖模块（模块c），更多的话<code>deps: [&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]</code><br>require.js基本用法就这些，查看更多当然去<a href="http://requirejs.org/" target="_blank" rel="noopener">官网</a>了，如需要还有<a href="https://github.com/requirejs/requirejs/wiki/Plugins" target="_blank" rel="noopener">插件</a>。<h2 id="别被RequireJS，CommonJS，AMD，CMD搞混了"><a href="#别被RequireJS，CommonJS，AMD，CMD搞混了" class="headerlink" title="别被RequireJS，CommonJS，AMD，CMD搞混了"></a>别被RequireJS，CommonJS，AMD，CMD搞混了</h2>RequireJS只是实现AMD规范的一个js文件”加载器”,类似的加载器有很多，github上很多大牛都写过。<br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a>作为一种规范，在<a href="https://webpack.github.io/docs/commonjs.html" target="_blank" rel="noopener">CommonJS</a>规范上做了改良，但业界也有争议和不足，比如：<em>所有加载的模块不管用没用到，都已经预先执行</em>。所以又产生了<a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="noopener">CMD</a>集各规范之所长的<a href="http://seajs.org/docs/" target="_blank" rel="noopener">SeaJS</a>。这些规范从CommonJS，到AMD，再到CMD，在社区内讨论争议的各个派系很多，里面很有故事，程序员之间也有种“文人相轻”的感觉。</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/03/01/深入理解margin-collapsing/" class="prev">上一篇</a><a href="/2016/02/26/为什么排期总是不合理？/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2016/02/28/RequireJS入门/';
var disqus_title = 'RequireJS入门';
var disqus_url = 'http://chayangge.com/2016/02/28/RequireJS入门/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2014 - 2019 <a href="http://chayangge.com">插秧哥</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>